name: councilwatch

services:
  client:
    build:
      context: .
      dockerfile: client.Dockerfile
    ports:
      - "${COUNCILWATCH_PORT}:8080"
    networks:
      - frontend
    # The server MUST be started first or nginx will crash
    depends_on:
      - server
    profiles: [prod, production]

  server:
    build:
      context: .
      dockerfile: server.Dockerfile
    environment:
      - DATABASE_URL=postgres://councilwatch:${POSTGRES_PASSWORD}@database:5432/councilwatch
      - APP_HOST=server_frontend
      - APP_PORT=8080
      - JWT_AUDIENCE=${JWT_AUDIENCE}
      - JWT_ISSUER=${JWT_ISSUER}
      - JWT_SECRET=${JWT_SECRET}
      - JWT_LIFETIME=${JWT_LIFETIME}
    networks:
      frontend:
        aliases:
          - server
          - server_frontend
      backend:
        aliases:
          - server_backend
    depends_on:
      - database
    profiles: [prod, production]

  database:
    image: "postgres:18"
    environment:
      - POSTGRES_DB=councilwatch
      - POSTGRES_USER=councilwatch
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - councilwatch_data:/var/lib/postgresql/data
    networks:
      - backend
    profiles: [prod, production]

  # A temporary database for development purposes
  db_development:
    image: "postgres:18"
    environment:
      - POSTGRES_DB=councilwatch
      - POSTGRES_USER=councilwatch
      - POSTGRES_PASSWORD=councilwatch
    ports:
      - 5432:5432
    profiles: [dev, devel, develop, development]

volumes:
  councilwatch_data:

networks:
  # Network isolation so, for example, the frontend cannot access the database
  backend:
  frontend:
